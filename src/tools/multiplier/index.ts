import { tool } from "@langchain/core/tools";
import { z } from "zod";
import { saveOutput } from "../../rag/utils";
import { chatGroq } from "../../utils/models";

// TODO: Read 'https://js.langchain.com/docs/how_to/custom_tools/'

// Let's create a tool that multiplies two numbers.
const func = ({ a, b }: { a: number; b: number }): string => (a * b).toString();

// We'll call it 'multiplyTool' because for tool calling it doesn't require a fn()
// to execute, you can also define just the tool schema. (See further below...)
const multiplyTool = {
  name: "multiply",
  description: "Multiply two numbers",
  schema: z.object({ a: z.number(), b: z.number() }),
};

const multiply = tool(func, multiplyTool);

// * LangChain has a few other ways to create tools; e.g., by sub-classing the
// * 'StructuredTool' class or by using 'StructuredTool' and 'StructuredToolParams'.
// * These methods are shown in the 'how to create custom tools' guide, but since
// * @langchain/core v0.2.7 we recommend using the 'tool' function for most cases.

multiply
  .invoke({ a: 2, b: 3 })
  .then((simpleResult) =>
    saveOutput("simpleResult", simpleResult, "./src/tools/multiplierExample/output/")
  );

// * Sometimes there are artifacts of a tool’s execution that we want to make
// * accessible to downstream components in our chain or agent, but that we don’t
// * want to expose to the model itself: we rather want to be able to access this
// * full output elsewhere, for example in downstream tools.

// TODO: First, make sure that we return a tuple of [content, artifact].
// TODO: Second, set responseFormat: "content_and_artifact" on defining the tool.
// TODO: Third, call it with a ToolCall rather than with the required schema directly.

const newToolFunction = async ({
  min,
  max,
  size,
}: {
  min: number;
  max: number;
  size: number;
}) => {
  const array: number[] = [];
  for (let i = 0; i < size; i++) {
    array.push(Math.floor(Math.random() * (max - min + 1)) + min);
  }
  // Make sure that we return a tuple of [content, artifact].
  return [
    `Successfully generated array of ${size} random ints in [${min}, ${max}].`,
    array,
  ];
};

const options = {
  name: "generateRandomInts",
  description: "Generate size random ints in the range [min, max].",
  schema: z.object({ min: z.number(), max: z.number(), size: z.number() }),
  responseFormat: "content_and_artifact", // Set the response_format parameter to "content_and_artifact" when defining the tool.
};

const genRandomInts = tool(newToolFunction, options);

// If you invoke our tool directly with the tool arguments, you’ll get back just the
// content part of the output:
genRandomInts
  .invoke({ min: 1, max: 10, size: 5 })
  .then((invokeWithToolArgsResult) =>
    saveOutput(
      "invokeWithToolArgsResult",
      invokeWithToolArgsResult,
      "./src/tools/multiplierExample/output/"
    )
  );

// But if you invoke our tool with a ToolCall, you’ll get back a ToolMessage that
// contains both the content and artifact generated by the Tool:
genRandomInts
  .invoke({
    name: "generateRandomInts",
    args: { min: 1, max: 10, size: 5 },
    id: "123",
    type: "tool_call",
  })
  .then((invokeWithToolCallResult) =>
    saveOutput(
      "invokeWithToolCallResult",
      invokeWithToolCallResult,
      "./src/tools/multiplierExample/output/"
    )
  );

// Afterwards we need to bind the tool to a model that supports tool calling.
// This gives the model awareness of the tool and the associated input schema
// required by the tool.
const modelWithTools = chatGroq.bindTools([multiply, genRandomInts]);

// Now we can call the model with the tool call arguments.
modelWithTools.invoke("What is the result of multiplying 2 and 3?").then((result) =>
  saveOutput("result", result, "./src/tools/multiplierExample/output/")
);
